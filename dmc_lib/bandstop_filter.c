/*=====================================================================================
 File name:    PMSM_BSF.C  (IQ version)
                    
 Originator:     Triol / Sosnovchik
URL: 			http://www.dsplib.ru/content/notch/notch.html

 Description:  Bandstop filter

=====================================================================================
 History:
-------------------------------------------------------------------------------------
 22-12-2011 Version 1.00      
-------------------------------------------------------------------------------------*/

#include "Global_Include.h"
#include "type.h"
#include "bandstop_filter.h"

BSF	reject1 = BSF_DEFAULTS;
BSF	reject2 = BSF_DEFAULTS;

//========================================================================
void BandStopFilter_calc(BSF *v)
{   
  f32	Fnykv; // Частота Найквиста (половина частоты дискретизации)
  f32	tmpB, tmpA1;
  
  if (v->Enable) {  // Если обработка разрешена - выполняем её
    
    // 1) Расчет коэффициентов фильтра
    
    /* Перед вызовом инициализации надо:
    * 1. Задать частоту дискретизации в Гц.
    * 2. Указать частоту режекции в Гц
    * 3. Указать полосу пропускания в Гц
    */
    
    // http://www.dsplib.ru/content/notch/notch.html
    Fnykv = v->Fsample / 2.0f; // Частота Найквиста
    v->K1 = -arm_cos_f32( (v->Fstop*PI) / Fnykv ); // Коэф. отвечает на центральную частоту
    tmpB = (v->Bandwidth*PI) / Fnykv ;
    v->K2 = ( 1 -  arm_sin_f32(tmpB) ) / arm_cos_f32(tmpB); // Коэф. отвечает за полосу пропускания
    
    tmpA1 = ( (1 + v->K2) / 2.0 );
    v->A1 = tmpA1;			// Коэффициент при значении X(i) -   A1 = (1+k2)/2
    v->A2 = 2.0 * tmpA1 * v->K1;		// Коэффициент при значении X(i-1) - A2 = A1*2*K1
    v->A3 = v->A1;			// Коэффициент при значении X(i-2) - A3 = A1
    v->B1 = v->K1 * (1.0 + v->K2);	// Коэффициент при значении Y(i-1) - B1 = K1*(1+K2)
    v->B2 = v->K2;			// Коэффициент при значении Y(i-2) - B2 = K2
            
    // 2) Filter calculation
    v->Xi[0] = v->In;
    
    // Сдвигаем выходные отсчеты вектора Yi
    v->Yi[2] = v->Yi[1];
    v->Yi[1] = v->Yi[0];
        
    // Расчет выходного значения
    v->Yi[0] = (v->A1*v->Xi[0]) + (v->A2*v->Xi[1]) + (v->A3*v->Xi[2]) - (v->B1*v->Yi[1]) - (v->B2*v->Yi[2]);
    
    // Сдвигаем входные отсчеты
    v->Xi[2] = v->Xi[1];
    v->Xi[1] = v->Xi[0];
    
    // Выходное значение
    v->Out = v->Yi[0];
  } else { // если фильтрация блокирована
    v->Out = v->In; // Просто передаем вход на выход
  }
}
//========================================================================
void BandStopFilter_init(BSF *v)
{   
    // Сброс начальных векторов
    v->Xi[0] = 0;      	v->Xi[1] = 0;      	v->Xi[2] = 0;
    v->Yi[0] = 0;	v->Yi[1] = 0; 		v->Yi[2] = 0;
}
//========================================================================
