#include    "GT_DEFs.h"

#ifdef    GET_FUNC_CODE
typedef struct{
    u16  Pnt_Nfunc;
    u16  Pnt_State;
//    u16  Pnt_nvState;
    u16  Pnt_mull_U;                       //1  mull_U
    u16  Pnt_F;                            //2  F
    u16  Pnt_F5_1;                         //3  F5_1
    u16  Pnt_F4_1;                         //4  F4_1
    u16  Pnt_F3_1;                         //5  F3_1
    u16  Pnt_F2_1;                         //6  F2_1
    u16  Pnt_F1_1;                         //7  F1_1
    u16  Pnt_U5_1;                         //8  U5_1
    u16  Pnt_U4_1;                         //9  U4_1
    u16  Pnt_U3_1;                         //10  U3_1
    u16  Pnt_U2_1;                         //11  U2_1
    u16  Pnt_U1_1;                         //12  U1_1
    u16  Pnt_U0_1;                         //13  U0_1
    u16  Pnt_F5_2;                         //14  F5_2
    u16  Pnt_F4_2;                         //15  F4_2
    u16  Pnt_F3_2;                         //16  F3_2
    u16  Pnt_F2_2;                         //17  F2_2
    u16  Pnt_F1_2;                         //18  F1_2
    u16  Pnt_U5_2;                         //19  U5_2
    u16  Pnt_U4_2;                         //20  U4_2
    u16  Pnt_U3_2;                         //21  U3_2
    u16  Pnt_U2_2;                         //22  U2_2
    u16  Pnt_U1_2;                         //23  U1_2
    u16  Pnt_U0_2;                         //24  U0_2
    u16  Pnt_GTstate;                      //25  GTstate
    u16  Pnt_Reset;                        //26  Reset
    u16  Pnt_TimeUSt;                      //27  TimeUSt
    u16  Pnt_PickUp;                       //28  PickUp
    u16  Pnt_Tfiltr;                       //29  Tfiltr
    u16  Pnt_SelNum;                       //30  SelNum
    u16  Pnt_DinSel;                       //31  DinSel
    u16  Pnt_Error;                        //32  Error
    u16  Pnt_WaitUF;                       //33  WaitUF
    u16  Pnt_U;                            //34  U
    u16  Pnt_End;
}FuncUF5_F2S_type;
//********************************************************
typedef struct{
		_iq     F5;
		_iq     F4;
	    _iq     F3;
	    _iq     F2;
	    _iq     F1;
	    _iq     U5;
	    _iq     U4;
	    _iq     U3;
	    _iq     U2;
	    _iq     U1;
   	    _iq     U0;
        
        s32     TimeUStart;
        s16     PrevRes;
        s16     PrevSet;
        s16		PrevSelUF;
}UF5_F2SState_type;
//********************************************************
//Проверить переход с одной характеристики на другую. Чтобы не было бросков напряжения
//********************************************************
u16 *FuncUF5_F2S_1(FuncUF5_F2S_type *progPnt, u32 ramPnt)
{
	UF5_F2SState_type 		*sPnt;
	s16                     Tfiltr;
	u16						*u16PntStart;
	_iq                     F, U, Ftmp[5], *iqPntF, *iqPntU, *iqPnt;
	u16						*u16PntU, *u16PntF;
	s16                     time, tmp, tmp1, Num;

	sPnt = (UF5_F2SState_type *)(ramPnt + progPnt->Pnt_State);
	F =  _IQabs(load_s32(ramPnt, progPnt->Pnt_F));
	Tfiltr = load_s16(ramPnt, progPnt->Pnt_Tfiltr);

	if(flagIsFirstCall){            //начальная инициализация
	    Tfiltr = 0;
	}

	if (testBitMicro(ramPnt, progPnt->Pnt_PickUp) == 0){
        tmp  = load_s16(ramPnt, progPnt->Pnt_GTstate) & RefZero;    //!!!tmp  = testBitMicro(ramPnt, progPnt->Pnt_GT_ZR);
        tmp1 = load_s16(ramPnt, progPnt->Pnt_GTstate) & EquRV;      //!!!tmp1 = testBitMicro(ramPnt, progPnt->Pnt_GT_RV);
        time = load_s16(ramPnt, progPnt->Pnt_TimeUSt);
/*
		if(!sPnt->PrevSet && tmp1){ // Каждый раз при переходе на Fпуск. замораживаем генератор темпа
            setBitMicro(ramPnt, progPnt->Pnt_WaitUF);
        }
        if(testBitMicro(ramPnt, progPnt->Pnt_WaitUF) == 1){
            sPnt->TimeUStart += (time == 0) ? _IQ(1.0): (_IQ(INT_TIME_CALL_MICRO_mS)/ time);
            if (sPnt->TimeUStart > _IQ(1.f)){ // пока поднимаем напряжение,- генератор темпа заморожен 
                sPnt->TimeUStart = _IQ(1.f);
                clrBitMicro(ramPnt, progPnt->Pnt_WaitUF);
            }
        }
        if(!sPnt->PrevRes && tmp){ // Каждый раз при переходе на нулевую частоту имеем напряжение равное "0"
            sPnt->TimeUStart = 0;
            clrBitMicro(ramPnt, progPnt->Pnt_WaitUF);
        }

        if((tmp == 1) && (tmp1 == 1)){ // Если пусковая частота задана равной "0", то имеем не "0" выход по напряжению в СТОПе
            sPnt->TimeUStart = _IQ(1.f);
        }
        sPnt->PrevRes = tmp;
        sPnt->PrevSet = tmp1;
*/
        if(testBitMicro(ramPnt, progPnt->Pnt_Reset) == 1){     //-- Стоим, ШИМ отключен
			Tfiltr = 0;	//Фильтровать в стопе нет необходимости
            sPnt->TimeUStart = _IQ(0.0);
            clrBitMicro(ramPnt, progPnt->Pnt_WaitUF);
        }
        else if(tmp1 == EquRV){                                //-- Если работаем на пусковой частоте
      		if(sPnt->TimeUStart == _IQ(0.0)){                  // На время подъема напряжения замораживаем генератор темпа
                setBitMicro(ramPnt, progPnt->Pnt_WaitUF);
            }
            if(testBitMicro(ramPnt, progPnt->Pnt_WaitUF) == 1){
                sPnt->TimeUStart += (time == 0) ? _IQ(1.0): (_IQ(INT_TIME_CALL_MICRO_mS)/ time);
                if (sPnt->TimeUStart > _IQ(1.f)){
                    sPnt->TimeUStart = _IQ(1.f);
                    clrBitMicro(ramPnt, progPnt->Pnt_WaitUF);  // Поднияли напряжение и разморозили генератор темпа
                }
            }
        }
        else if(tmp == RefZero){                               //-- Если работаем на нулевой частоте и она не пусковая
            //sPnt->TimeUStart = _IQ(0.0);                       // Выдаем выходное напряжение равное нулю
        }
    }
    else{
        sPnt->TimeUStart = _IQ(1.f);
    }
//-- Выбор характеристики
	Num = load_s16(ramPnt, progPnt->Pnt_SelNum);
	if(Num >= 2){
		Num = testBitMicro(ramPnt, progPnt->Pnt_DinSel);
	}
//-- Вычитка переменных	
    if (Num == 0){
		u16PntF		= &(progPnt->Pnt_F5_1);
		u16PntU		= &(progPnt->Pnt_U5_1);
    }else{
		u16PntF		= &(progPnt->Pnt_F5_2);
		u16PntU		= &(progPnt->Pnt_U5_2);
    }
	
	u16PntStart = u16PntF;
	iqPnt	= Ftmp;																//F5
	for(tmp = 5; tmp >0; tmp--, iqPnt++, u16PntF++){							//вычитываем во временный буфер F5, F4, F3, F2, F1
		*iqPnt = load_s32(ramPnt, *u16PntF);
	}
	
	u16PntF	= u16PntStart;
	iqPntF	= &(sPnt->F5);
	iqPntU	= &(sPnt->U5);
	iqPnt	= Ftmp;
	for(tmp = 4; tmp >0; tmp--, u16PntF++, u16PntU++, iqPnt++, iqPntF++, iqPntU++/*!!!*/){		//проверяем на превышение
		if(iqPnt[1] > *iqPnt){															//F4>F5		F3>F4		F2>F3		F1>F2
			iqPnt[1] = *iqPnt;															//F4=F5		F3=F4		F2=F3		F1=F2
			save_s32(ramPnt, *u16PntF, (s32)*iqPnt);									//save_s32(ramPnt, progPnt->Pnt_F5_1, F5);
		}
		*iqPntF = iq_Filtr_prm(*iqPntF, *iqPnt, Tfiltr);								//sPnt->F1 = iq_Filtr_prm(sPnt->F5, F5), Tfiltr);
		*iqPntU = iq_Filtr_prm(*iqPntU, load_s32(ramPnt, *u16PntU), Tfiltr);			//sPnt->U5 = iq_Filtr_prm(sPnt->U5, load_s32(ramPnt, progPnt->Pnt_U5_1), Tfiltr);
	}
	*iqPntF = iq_Filtr_prm(*iqPntF, *iqPnt, Tfiltr);								//!!!sPnt->F1 = iq_Filtr_prm(sPnt->F1, F1), Tfiltr);
	*iqPntU = iq_Filtr_prm(*iqPntU, load_s32(ramPnt, *u16PntU), Tfiltr);			//!!!sPnt->U1 = iq_Filtr_prm(sPnt->U1, load_s32(ramPnt, progPnt->Pnt_U1_1), Tfiltr);
	*iqPntU++; *u16PntU++;
	*iqPntU = iq_Filtr_prm(*iqPntU, load_s32(ramPnt, *u16PntU), Tfiltr);			//!!!sPnt->U0 = iq_Filtr_prm(sPnt->U0, load_s32(ramPnt, progPnt->Pnt_U0_1), Tfiltr);

	//-- Расчёт
	if     (F >  sPnt->F4)  U = iq_Fy_x1x2y1y2x(sPnt->F4, sPnt->F5, sPnt->U4, sPnt->U5, F); //!!!F = заменил на U = iq_Fy....
	else if(F >  sPnt->F3)  U = iq_Fy_x1x2y1y2x(sPnt->F3, sPnt->F4, sPnt->U3, sPnt->U4, F); //!!!F = заменил на U = iq_Fy....
	else if(F >  sPnt->F2)  U = iq_Fy_x1x2y1y2x(sPnt->F2, sPnt->F3, sPnt->U2, sPnt->U3, F); //!!!F = заменил на U = iq_Fy....
	else if(F >  sPnt->F1)  U = iq_Fy_x1x2y1y2x(sPnt->F1, sPnt->F2, sPnt->U1, sPnt->U2, F); //!!!F = заменил на U = iq_Fy....
	else                    U = iq_Fy_x1x2y1y2x(0       , sPnt->F1, sPnt->U0, sPnt->U1, F); //!!!F = заменил на U = iq_Fy....
        
	//if(_IQabs(U) > _IQ(1.0))    U = _IQ(1.0);	//!!! F заменил на U
	//U  = _IQmpy(U, load_s32(ramPnt, progPnt->Pnt_mull_U));	//!!!U  = load_s32(ramPnt, progPnt->Pnt_mull_U);
	//U  = _IQmpy(U, sPnt->TimeUStart);							//!!!U *= _IQmpy(F, sPnt->TimeUStart);
	U  = _IQmpy((_IQmpy(U, sPnt->TimeUStart)), load_s32(ramPnt, progPnt->Pnt_mull_U));

	if(_IQabs(U) > _IQ(1.0))    U = _IQ(1.0);	//!!! F заменил на U

	save_s32(ramPnt, progPnt->Pnt_U, U);
	
	return &progPnt->Pnt_End;
};
#endif
//********************************************************
#ifdef    GET_FUNC_TABL_OPIS
const char TblFuncUF5_F2S_1[34]={
        S32_PIN_TYPE | INPUT_PIN_MODE,     //1  mull_U
        S32_PIN_TYPE | INPUT_PIN_MODE,     //2  F
        S32_PIN_TYPE | INPUT_PIN_MODE,     //3  F5_1
        S32_PIN_TYPE | INPUT_PIN_MODE,     //4  F4_1
        S32_PIN_TYPE | INPUT_PIN_MODE,     //5  F3_1
        S32_PIN_TYPE | INPUT_PIN_MODE,     //6  F2_1
        S32_PIN_TYPE | INPUT_PIN_MODE,     //7  F1_1
        S32_PIN_TYPE | INPUT_PIN_MODE,     //8  U5_1
        S32_PIN_TYPE | INPUT_PIN_MODE,     //9  U4_1
        S32_PIN_TYPE | INPUT_PIN_MODE,     //10  U3_1
        S32_PIN_TYPE | INPUT_PIN_MODE,     //11  U2_1
        S32_PIN_TYPE | INPUT_PIN_MODE,     //12  U1_1
        S32_PIN_TYPE | INPUT_PIN_MODE,     //13  U0_1
        S32_PIN_TYPE | INPUT_PIN_MODE,     //14  F5_2
        S32_PIN_TYPE | INPUT_PIN_MODE,     //15  F4_2
        S32_PIN_TYPE | INPUT_PIN_MODE,     //16  F3_2
        S32_PIN_TYPE | INPUT_PIN_MODE,     //17  F2_2
        S32_PIN_TYPE | INPUT_PIN_MODE,     //18  F1_2
        S32_PIN_TYPE | INPUT_PIN_MODE,     //19  U5_2
        S32_PIN_TYPE | INPUT_PIN_MODE,     //20  U4_2
        S32_PIN_TYPE | INPUT_PIN_MODE,     //21  U3_2
        S32_PIN_TYPE | INPUT_PIN_MODE,     //22  U2_2
        S32_PIN_TYPE | INPUT_PIN_MODE,     //23  U1_2
        S32_PIN_TYPE | INPUT_PIN_MODE,     //24  U0_2
        S16_PIN_TYPE | INPUT_PIN_MODE,     //25  GTstate
        BIT_PIN_TYPE | INPUT_PIN_MODE,     //26  Reset
        S16_PIN_TYPE | INPUT_PIN_MODE,     //27  TimeUSt
        BIT_PIN_TYPE | INPUT_PIN_MODE,     //28  PickUp
        S16_PIN_TYPE | INPUT_PIN_MODE,     //29  Tfiltr
        S16_PIN_TYPE | INPUT_PIN_MODE,     //30  SelNum
        BIT_PIN_TYPE | INPUT_PIN_MODE,     //31  DinSel
        S16_PIN_TYPE | OUTPUT_PIN_MODE,    //32  Error
        BIT_PIN_TYPE | OUTPUT_PIN_MODE,    //33  WaitUF
        S32_PIN_TYPE | OUTPUT_PIN_MODE     //34  U
};
#endif
//********************************************************
#ifdef    GET_FUNC_OPIS
//SymbolName,  Prefix,  typePin, FuncPnt, SizeOfState, SizeOfNvState, ExeLogicBlock
OpisFuncBlock("UF5_F2S", "DA", TblFuncUF5_F2S_1, FuncUF5_F2S_1, sizeof(TblFuncUF5_F2S_1), sizeof(UF5_F2SState_type), 0, 1),
#endif
//********************************************************
#ifdef    GET_FUNC_PNT
    (pFuncMicro_type)FuncUF5_F2S_1,
#endif
//********************************************************
